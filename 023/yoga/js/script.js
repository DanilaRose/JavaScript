// КОНТЕКСТ ВЫЗОВА this
// Человек БОМЖ - не привязан к месту, поэтому он взаимодействует в рамках всего мира. Если дать этому человеку жилье или определенное место работы он будет взаимодействовать в рамках данной области - это и есть контекст вызова this

// 4 СПОСОБА ВЫЗОВА ФУНКЦИИ: 

// 1) Просто вызов функции - Window или undefined
// Window. Данная  функция не знает в каком контексте выполнятся и поэтому выполняется в объекте Window
function showThis() {
    console.log(this);
}
showThis(); // window

// Undefined.  Функция внутри функции все равно своим контекстом считает Window
// Интерпритация. Если у нашего бомжа есть кот, то у кота, как и у бомжа контекст исполнения будет Window, то есть весь мир 
function showThis(a,b) {
    console.log(this);
    function sum() {
        console.log(this);
        return this.a + this.b;
    }
    console.log(sum()); 
}
showThis(4, 5);
showThis(5, 5);
// Но как же тогда вычислить сумму????
//Использовать замыкание функции. То есть, если функция не может найти переменные внутри себя она поднимается выше и ищет переменные за пределами себя. В нашем случае в функции выше. Она видит, что в аргументе функции выше есть "a" и "b", находит совпадения и подставляет значения "4" и "5", "5" и "5".

'use strict';  // В стандарте ES6, когда функция не знает, где себя выполнить(то есть у них нет своего this), они получают не Window, а undefined, то есть они не могут найти свой контекст вызова

function showThis(a, b) {
    console.log(this);

    function sum() {
        console.log(this);
        return a + b;
    }
    console.log(sum());
}
showThis(4, 5); // 9
showThis(5, 5); // 10



// 2) Метод объекта this = объект
let obj = {  // Если функции является методом объекта, т.к. она находится в объекте, то контекст ее выполнения является сам объект
    a: 20,
    b: 15,
    sum: function () {
        console.log(this);
        function shout() {
            console.log(this); // если функция вызвана не как метод объекта, а как функция внутри функции, то контекстом ее выполнения является Window
        }
        shout(); // функция вызвана как функция внутри функции
    }
};
obj.sum();

// 3) Когда мы вызываем через new функцию this ссылается на новый созданный  объект. Конструктор(new) - this = новый созданный объект
// Пояснение к прошлому уроку
function User(name, id) { 
    this.name = name;  // Что ввобще означает эта запись??? В объеке this при помощи точки создаем новое свойство name
    this.id = id;  // Также и здесь - в объекте this создаем свойство id
    this.human = true;
    this.hello = function () {   
        console.log('Hello!' + this.name);  
    };
}
let ivan = new User('Ivan', 25),
    alex = new User('Alex', 20);

// 4) Указание конкретного контекста - call, apply, bind. Берем несколько бомжей и насильно помещаем их в какое-то учреждение. То есть мы насильно будем устанавливать контекст вызова

// Есть данные о каком-то пользователе
let user = {
    name: "John"
};
// Есть функция, которая выводит имя, которое должно получаться с каких-то данных
function sayName() {
    console.log(this); // Выводим контекст вызова функции this
    console.log(this.name); // Выводим то, что функция должна делать - выведим имя
}

// Сейчас эта функция и эти данные никак не связаны. Сейчас мы должны взять эти данные и связать с этой функцией, чтобы она их обработала
// Насильно привязываем контекст вызова(связываем функцию с этими данными)

console.log(sayName.call(user));
// console.log(sayName.apply(user));
// Первой строкой мы выводим наш this (console.log(this)) - то есть то, нв что ссылается наша функция
// Второй строкой мы выводим имя из этого объекта (concole.log(this.name))

// В чем разница между call и apply?

// let user = {
//     name: "John"
// };

// function sayName(surname) {   // Добавим в функцию аргумент 'surname'
//     console.log(this);
//     console.log(this.name + surname);
// }
// // А разница в том, что 
// console.log(sayName.call(user, 'Smith'));  // Метод call передает параметры в виде строки (если нужно передать 1 параметр)
// console.log(sayName.apply(user, ['Snow'])); // Метод  apply передает массив данных (если нужно передать кучу параметров)

// Но есть еще 1 метод для привязки контекста вызова...

// Метод bind - создает новую функцию, связанную с определенным контекстом

function count(number) {
    return this * number;
}
let double = count.bind(2); // Вызываем функцию count и при помощи метода bind, объявляем контекстом вызова для этой функции "2". Простыми словами - вместо this теперь подставляется 2
console.log(double(3)); // 6
console.log(double(10)); // 20




// Если в обработчике событий используем контекст вызова и используем обычное объявление callback function, то контекстом вызова будет сам элемент
let btn = document.querySelectorAll('.more')[0];

btn.addEventListener('click', function () {
    console.log(this); // получаем как контекст вызова сам элемент
    this.style.backgroundColor = 'red';
    function showThis() {
        console.logo(this);
    }
    showThis(); // Контекстом вызова у данной функции будет Window, т.к. контекстом вызова функции внутри функции является Window
});